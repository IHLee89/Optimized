# 성능 측정
-> 측정과 실험은 프로그램의 성능을 향상하려고 다양한 시도를 할 때, 결과를 비교할 수 있는 기반을 만들어준다.  
-> 널리 사용할 수 있으면서도 유용하며 비용이 저렴한 도구
> 1. 프로파일러(profiler) : 컴파일러 제작사가 컴파일러와 같이 제공한다. 프로그램 실행 중에 호출된 각 함수를 수행하는데 걸린 누적 시간을 표로 정리하여 보고서를 작성해준다.
> 2. 소프트웨어 타이머(software timer) : 프로파일러가 가격이 비싸거나 일부 임베디드 플랫폼에서 제공하지 않을 때 개발자가 만들어 사용하는 도구이다.  
>                                      (계산에 구속되지 않는 시간 측정에도 유용하다.)
> 3. 노트 : 실험실 노트나 이와 동등한 텍스트 파일은 최적화에서 없어서는 안되는 중요한 도구이다.
***
## 3.1 사고 방식 최적화
-> 최적화의 몇 가지 철학을 알아보자.
### 3.1.1 성능은 반드시 측정해야 합니다.
- 일반적인 감각으로는 성능의 점진적 변화를 알 수 없고, 수 많은 실험 결과를 모두 정확하게 기억할 수도 없다.
- 책으로만 공부한다면 항상 사실이 아닐 수 도 있는 것을 항상 사실이라고 맹신하게 된다.
- 개발자는 코드의 어떤 부분을 최적화해야 할지에 대해 종종 잘못된 직감을 가진다.
- 프로그래밍 언어, 컴파일러, 라이브러리, 프로세서는 모두 발전하고 진화한다.  
  최적화가 끝났다고 생각했던 코드를 더 효율적인 코드로 바꿀 수도 있다.  
  반대로 최적화가 제대로 되지 않았다고 생각한 코드가 가장 최적화가 잘되었을 수도 있다.
### 3.1.2 최적화를 하는 사람은 맹수 사냥꾼입니다.
- 프로그램의 실행 속도 1% 빠르게 하는 작업은 버그의 위험보다 가치가 크지 않다.  
  또한 실행 속도 1% 빠르게 하는 작업은 성능 개선을 위장한 측정 오차(artifact)일 수 있고, 신뢰 수준으로 입증해야한다.  
  효과는 적은데 할 일은 많다. 
- 실행 속도 20%를 빠르게 하는 작업이라면 이야기가 다르다.  
  요점은 개발자가 어던 의문도 제기하지 못할 만큼 크고 극적인 성능 개선점을 찾게 하는데 있다.
- 개선된 코드는 운영체제나 컴파일러, 하드웨어에 따라서 큰 영향을 미치지 않을 수 있다.  
  하지만 극적으로 개선된 코드는 새로운 시스템에 이식해도 성능상 우위를 가질 확률이 높다.
### 3.1.3 90 / 10 규칙
- 최적화 기본 규칙에는 '프로그램 코드의 10%가 실행 시간의 90%를 소비한다'는 90 / 10 규칙이 있다.
- 특정 코드 블록이 매우 비번하게 실행되며 코드의 다른 부분은 거의 실행되지 않는다는 점을 알려준다.  
  이러한 특정 코드 블록이 최적화 작업의 대상이 된다.
- 모든 루틴을 최적화하는 것이 능사가 아니다.
- 자주 실행되는 10%가 어디인지 찾는 것이 중요하다.
### 3.1.4 암달의 법칙 (Amdahl's law)
- 최적화된 코드가 전체 프로그램 실행 시간의 상당 부분을 차지하지 않으면, 아무리 성공적인 최적화라도 가치가 없다.
***
## 3.2 실험 수행
1. 실험으로 검증한다. (실험은 증명이 아니다.)
2. 개선 결과가 예상보다 너무 좋으면 실험을 다시하거나, 가정에 의문을 제기하거나, 버그를 찾아라.
### 3.2.1 연구 노트를 보관하세요
- 성능 테스트 도중 기존 결과와 비교가 필요한 경우가 발생할 수 있다.
- 각 테스트를 문서화하면 반복 수행을 빠르게 하 수 있다.
### 3.2.2 성능 측정 기준과 목표 설정
- 최적화 이전의 성능 측정 값과 성능 목표는 최적화에 쓰이는 비용에 정당성을 부여해준다.
- 안타깝게도 최적화는 노력에 대한 보상(성능 개선)이 점점 줄어드는 과정이다.
#### 시작 시간
- 엔터 키를 누른 후에 프로그램이 메인 입력 처리 루프에 들어가기까지 걸리는 시간
#### 종료 시간
- 사용자가 닫기 명령을 입력한 후부터 프로세스가 실제로 종료될 때까지 걸린 시간
#### 응답 시간
- 명령을 수행하는데 걸리는 평균 시간 또는 최악의 경우를 고려한 시간
- 0.1초 미만 : 사용자가 직접적인 제어권을 가짐
- 0.1초 ~ 1초 : 사용자가 제어권을 가짐
- 1초 ~ 10초 : 컴퓨터에 제어권이 있음
- 10초 이상 : 커피 마실 시간
#### 처리량
- 응답 시간의 역수. 단위 시간당 평균 작업 수
### 3.2.3 측정한 것만 개선할 수 있습니다.
***
## 3.3 프로그램 실행 프로파일
- 프로파일러는 어떤 프로그램이 어디에 시간을 쓰는지 통계 자료를 생성하는 프로그램이다.
- 프로파일러는 가능한 저렴한 비용으로 측정할 수 있도록 설계되어서 모든 작업에 대해 단 몇 퍼센트의 속도 저하만 발생한다.
### 3.3.1 첫 번째 프로파일 방법
1. 프로파일링할 프로그램에 모든 함수를 측정하라고 지시하는 특수한 컴파일러 플래그를 붙여 다시 컴파일한다.
2. 측정할 프로그램과 프로파일링 라이브러리를 링크한다.
3. 측정할 프로그램을 실행할 때마다 프로파일링 테이블을 디스크에 파일로 저장한다.
4. 프로파일러는 프로파일링 테이블을 입력으로 사용해 텍스트 또는 그래픽 보고서를 생성한다.

-> 장단점 : 정확한 결과를 제공하지만 오버헤드 비용이 많고 특정 최적화를 비활성화 한다.
### 3.3.2 두 번째 프로파일 방법
1. 수정하지 않은 프로그램을 프로파일링 라이브러리와 링크해 측정한다.
2. 측정할 프로그램을 실행할 때마다 프로파일링 테이블을 디스크에 파일로 저장한다.
3. 프로파일러는 프로파일링 테이블을 입력으로 사용해 텍스트 또는 그래픽 보고서를 생성한다.

-> 장단점 : 근사 결과를 제공하고 자주 호출되지 않는 함수르 몇 개 놓칠 수도 있지만 프로덕션 코드를 실행할 수 있는 장점이 있다.  
-> 개발 단계에서 컴파일/빌드되는 프로그램은 일반적으로 디버그나 성능 측정을 위한 디버깅 센셕 등 추가 정보를 가지고 있다.  
   프로덕션 코드는 이런 불필요한 정보가 없는 프로그램을 통칭한다.
***
## 3.4 시간이 오래 걸리는 코드

***
체계적인 최적화 작업 순서
1. 테스트 가능한 예측(perdiction)을 만들고 적는다.
2. 코드 변경 사항을 기록한다.
3. 사용 가능한 최고의 측정기로 측정한다.
4. 실험 겨과의 자세한 내용을 보관한다.  
-> 개발자는 대부분 체계적인 방법으로 작업하지 않는다. 이는 연습이 필요한 기술이다.
